
Application Program Interface
=============================


**Files**

+---------------------+--------------------------------------------------------------------------------------+
|File                 |   Description                                                                        |
+=====================+======================================================================================+
|Personis_base.py     |the core library that accesses models in local directories/files                      |
+---------------------+--------------------------------------------------------------------------------------+
|Personis_a.py        |adds 'Active User Models' to Personis. This allows components to                      |
|                     |be 'subscribable' and statements in a simple language to be executed                  |
|                     |when new component values satisfy a condition.                                        |
+---------------------+--------------------------------------------------------------------------------------+
|Personis_base.py     |the core library that accesses models in local directories/files                      |
+---------------------+--------------------------------------------------------------------------------------+
|Personis_a.py	      |adds 'Active User Models' to Personis. This allows components to                      |
|		      |be 'subscribable' and statements in a simple language to be executed                  |
|		      |when new component values satisfy a condition.                                        |
+---------------------+--------------------------------------------------------------------------------------+
|Personis_server.py   |a server and set of stubs for the server version of Personis                          |
|		      |uses Personis_a.py to do the work                                                     |
+---------------------+--------------------------------------------------------------------------------------+
|Personis.py 	      |a wrapper for Personis_server                                                         |
+---------------------+--------------------------------------------------------------------------------------+
|Tests/*	      |scripts to test the system                                                            |
+---------------------+--------------------------------------------------------------------------------------+
|Tests/Base/example*  |a set of code examples for models stored locally                                      |
+---------------------+--------------------------------------------------------------------------------------+
|Tests/Server/example*|a set of code examples for models stored on a server                                  |
+---------------------+--------------------------------------------------------------------------------------+
|mkmodel	      |utility program to make a set of models from a                                        |
+---------------------+--------------------------------------------------------------------------------------+
|modeldef	      |definition file                                                                       |
+---------------------+--------------------------------------------------------------------------------------+


.. automodule:: personis
   :members:

**Constants**

ComponentTypes::

	"attribute"
	"activity"
	"knowledge"
	"belief"
	"preference"
	"goal"

ValueTypes::

	"string"
	"number"
	"boolean"
	"enum"
	"JSON"

EvidenceTypes::

	"explicit"  # given by the user  (given)
	"implicit"  # observed by the machine (observation)
	"exmachina" # told (to the user) by the machine (told)
	"inferred"  # evidence generated by inference (external or internal)
	"stereotype" # evidence added by a stereotype

**Functions**

|	MkModel(model=None, modeldir=None, user=None, password=None, description=None):
|		make a model with name "model" in directory modeldir for "user"/"password" with "description"

**Classes**

::

	Component: component object
		Identifier	the identifier of the component
				unique in the context
		Description	readable description
		component_type	["attribute", "activity", "knowledge", "belief", "preference", "goal"]
		value_type	["string", "number","boolean", "enum", "JSON"]
		value_list      a list of strings that are the possible values for type "enum"
		value		the resolved value
		resolver	default resolver for this component
		goals		list of component paths eg [ ['Personal', 'Health', 'weight'], ...]
		evidencelist	list of evidence objects

	Evidence: evidence object
		evidence_type	"explicit", # given by the user
				"implicit", # observed by the machine
				"exmachina", # told (to the user) by the machine
				"inferred", # evidence generated by a subscription inference 
				"stereotype"] # evidence added by a stereotype
		source	string indicating source of evidence
		value	any python object
		comment string with extra information about the evidence
		flags	a list of strings eg "goal"
		time    timestamp
		useby   timestamp evidence expires (if required)

	Context: context object
		Identifier	the identifier of the component
				unique in the context
		Description	readable description
		resolver	default resolver for components in this context

	View: view object
		Identifier	the identifier of the component
				unique in the context
		Description	readable description

	Access(Resolvers.Access): user model object
		model		model name
		modeldir	model directory
		user		user name
		password	password string
	returns a user model access object 

Access methods::

	def ask(self,  context=[], view=None, resolver=None, showcontexts=None):
		context is a list giving the path of context identifiers
		view is either:
			an identifier of a view in the context specified
			a list of component identifiers or full path lists
			None indicating that the values of all components in
				the context be returned
		resolver is a string containing the name of a resolver
			or
		resolver is a dictionary containing information about resolver(s) to be used and arguments
			the "resolver" key gives the name of a resolver to use, if not present the default resolver is used
			the args may include a specified evidence filter
			eg 'evidence_filter' =	"all" returns all evidence,
						"last10" returns last 10 evidence items,
						"last1" returns most recent evidence item,
						None returns no evidence
		showcontexts: if True, a tuple is returned containing 
			(list of component objects, 
			list of contexts in the current context,
			list of views in the current context,
			list of subscriptions in the current context)
		returns a list of component objects

	def tell(self, context=[], componentid=None, evidence=None,   # evidence obj dosubs=True):
		arguments:
			context - a list giving the path to the required context
			componentid - identifier of the component
			evidence - evidence object to add to the component

	def export_model(self,  context=[], evidence_filter=None, level=None):
		context is a list giving the path of context identifiers
			this is the root of the um tree to export
		evidence_filter specifies an evidence filter 
			(partially implemented: "all" returns all evidence,
						"last10" returns last 10 evidence items,
						"last1" returns most recent evidence item,
						None returns no evidence)
		returns a JSON encoded representation of the um tree

	def import_model(self, context=[], partial_model=None):
		arguments:
		context - context to import partial model to
			if None, use root of model
		partial_model - string containing JSON representation of model dictionary
			OR
			a dictionary with elements:
				contextinfo - Description, Identifier, perms, resolver
				contexts - sub contexts
				components
				views
				subs
	
	def set_goals(self, context=[], componentid=None, goals=None):
		set the goal list for a component
		requires "tell" permission
		arguments:
			context - a list giving the path to the required context
			componentid - identifier of the component
			goals - list of goal component paths

	def mkcomponent(self, context=[], componentobj=None):
		Make a new component in a given context
		arguments:
			context - a list giving the path to the required context 
			componentobj - a Component object
		returns:
			None on success
			a string error message on error

	def delcomponent(self, context= [], componentid=None):
		Delete an existing component in a given context
		arguments:
			context - a list giving the path to the required context 
			id - the id for a componen
		returns:
			None on success
			a string error message on error

	def mkcontext(self, context= [], contextobj=None):
		Make a new context in a given context
		arguments:
			context - a list giving the path to the required context 
			contextobj - a Context object
		return True if created ok, False otherwise

	def delcontext(self, context=[]):
		Delete an existing context
		arguments:
			context - a list giving the path to the required context 
		returns:
			None on success
			a string error message on error

	def getcontext(self, context=[], getsize=False):
		get information (Description, size etc) of a context
		arguments:
			context - a list giving the path to the required context 
			getsize - if True, return the size in bytes of the context subtree
		returns:
			None on success
			a string error message on error

	def registerapp(self, app=None, desc="", password=None):
		registers a password for an app
		app name is a string (needs checking TODO)
		desc is the app description string
		app passwords are stored at the top level .model db
		returns a dictionary containing description and password(access key)

	def deleteapp(self, app=None):
		deletes an app

	def listapps(self):
		returns an dictionary of apps that are registered
		key is app name, 'description' is app description

	def setpermission(self, context=None, componentid=None, app=None, permissions={}):
		sets ask/tell permission for a context (if componentid is None) or
			a component

	def setresolver(self, context, componentid, resolver):

	def getresolvers(self):

	def mkview(self, context= [], viewobj=None):
		Make a new view in a given context
		arguments:
			context - a list giving the path to the required context 
			viewobj - a View object

	def delview(self, context=[], viewid=None):
		Delete an existing view within a given context
		arguments:
			context - a list giving the path to the required context 
			viewid - view identifier
		returns:
			on success, None
			on failure, a string reporting the problem

	def subscribe(context=[], view=None, subscription=None):
		add a subscription to the component specified by the context and view
		arguments:
			context - a list giving the path to the required context
                        viewobj - a View object
			subscription - is a dictionary containing owner, password and subscription statement string
		returns a token that can be used to delete the subscription

	def delete_sub(context=[], componentid=None, subname=None):
		deletes a subscription specified by the token subname in the component specified by the context and componentid
		arguments:
			context - a list giving the path to the required context
			componentid - name of component in the context
			subname - a token return from the subscribe call when the subscription is installed
					also available using an ask call with showcontexts=True

Examples
--------

Models can be accessed either locally in the filesystem, or via a server. 

Local access is via the Personis_base module.  

**Basic accretion operation - tell some evidence**

The following example shows the use of Personis_base to *tell* a piece of evidence 
containing a name string to a component in the model.  The source of the evidence is "contactapp" which will have
been given access to the model by the owner.

::

	import Personis_base
	
	# access the model in the filesystem
	# model name is "alice", model is stored in directory "Models"
	um = Personis_base.Access(model="alice", modeldir='Models', user='contactapp', password='secret')

	# create a piece of evidence with Alice as value
	ev = Personis_base.Evidence(evidence_type="explicit", value="Alice")

	# tell this as user alice's first name into component "firstname", context "Personal"
	um.tell(context=["Personal"], componentid="firstname", evidence=ev)

**Basic resolution operation - ask for a value**

This example *ask*s for the value of a component using the default resolver that uses the most recent piece of 
evidence.

::

	import Personis_base
	
	um = Personis_base.Access(model="alice", modeldir='Models', user='contactapp', password='secret')

	# now ask for the value of the component using the default resolver and the last piece of evidence
	reslist = um.ask(context=["Personal"], view=["firstname"], resolver=dict(evidence_filter="last1"))
	
A *view* is just a list of components. The list can be explicit in the ask request or we can give a view a 
name and store it in the model.

For example::

	# now ask for the value of two components using a view
	reslist = um.ask(context=["Personal"], view=["firstname", "lastname"], resolver=dict(evidence_filter="last1"))

We can make a view using a view object and the *mkview* method. For example::


	import Personis_base
	
	um = Personis_base.Access(model="alice", modeldir='Models', user='contactapp', password='secret')

	vobj = Personis_base.View(Identifier="fullname", component_list=["firstname", "lastname"])
	um.mkview(context=["Personal"], viewobj=vobj)

	reslist= um.ask(context=["Personal"], view = 'fullname', resolver={'evidence_filter':"all"})

The values are returned by an ask request in a list of component objects, one for eachc component value requested.
The component objects have the attributes described in the documentation above but this includes 
a *value* attribute  which is the resolved value for the component. Eg::

	reslist = um.ask(context=["Personal"], view=["firstname"], resolver=dict(evidence_filter="last1"))
	print "Firstname:", reslist[0].value

**Creating new contexts and components**

The *mkcontext* and *mkcomponent* methods, along with the *Component* and *Context* objects, are used to build
new elements in the model. Here is an example of creating and then deleting a context::

	# assume we have accessed the model
	print "creating context 'Deltest' in context 'Personal'"
	cobj = Personis_base.Context(Identifier="Deltest", Description="testing context deletion")
	# now make the new context
	um.mkcontext(context=["Personal"], contextobj=cobj)
	
	print "now delete it"
	um.delcontext(context=["Personal", "Deltest"]):

and here is an example of creating and then deleting a component::


	cobj = Personis_base.Component(Identifier="age", component_type="attribute", Description="age", goals=[['Personal', 'Health', 'weight']], value_type="number")
	
	um.mkcomponent(context=["Personal"], componentobj=cobj)
	
	# tell some evidence to the new component
	ev = Personis_base.Evidence(evidence_type="explicit", value=17)
	um.tell(context=["Personal"], componentid='age', evidence=ev)
	reslist = um.ask(context=["Personal"], view=['age'], resolver={'evidence_filter':"all"})
	print "Age:", reslist[0].value
	
	# delete the component
	resd = um.delcomponent(context=["Personal"], componentid = "age")
	
**Navigating the Model**

If you want to discover what contexts are present in the model there is a variant on the *ask* method that 
allows you to get a list of all the *contexts*, *components*, *views* and *subscriptions* that are 
contained in a given context. Just add the parameter "showcontexts=True" to the *ask* call.
Using this call you can start at the root context and walk the tree of contexts discovering the full 
contents of the model. Eg::

	print "Show the root context"
	info = um.ask(context=[""], showcontexts=True)

The return value is a tuple containing (componentlist, contextlist, viewlist, sublist), where each part 
of the tuple is a list of objects.

**Subscriptions: rules for action**

A feature of Personis is the ability to add a rule to a component that is examined when ever a *tell* operation
is performed on the component. The rule typically examines a resolved value of the component, matching against a 
pattern. If the pattern is matched an action is initiated. The action can be a *tell* operation to tell some 
evidence to a component, or a *notify* operation that will construct a URL and fetch it, thus initiating some 
action at an external web site.  Rules can be deleted using the *delete_sub* method.

Note that you need to use Personis_a instead of Personis_base as that is where the subscription methods are found.

For example::

	import Personis_base
	import Personis_a
	
	um = Personis_a.Access(model="alice", modeldir='Models', user='contactapp', password='secret')

	# subscription rule that will match firstname against a wildcard pattern (regular expression):
	sub = """
	<default!./Personal/firstname> ~ '.*' :
	         NOTIFY 'http://www.myweb.me/~alice/action.cgi?' 'firstname=' <./Personal/firstname> 
	"""
	
	# a token identifying the rule is returned
	subtoken = um.subscribe(context=["Personal"], view=['firstname'], subscription={'user':'alice', 'password':'secret', 'statement':sub})
	
	ev = Personis_base.Evidence(evidence_type="explicit", value="Alice")
	# do a tell. This should cause the action.cgi script to be invoked with the firstame
	um.tell(context=["Personal"], componentid='firstname', evidence=ev)

	# delete the rule
	um.delete_sub(context=["Personal"], componentid='lastname', subname=subtoken)

	
**Import and Export of Models**

Models can be imported and exported in JSON (JavaScript Object Notation)
form using the *export_model* and *import_model* methods::

	import Personis_base
	import Personis_a
	
	um = Personis_a.Access(model="alice", modeldir='Models', user='contactapp', password='secret')
	
	# export a model sub tree to JSON
	# note that all evidence will also be exported.
	modeljson = um.export_model(["Personal"], evidence_filter="all")
	print modeljson
	
	# import the same model tree but into a different context.
	um.import_model(context=["Temp"], partial_model=modeljson)
	
