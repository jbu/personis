% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Personis Documentation}
\date{August 21, 2012}
\release{12.9}
\author{Bob Kummerfeld and Judy Kay}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Introduction}
\label{Intro:introduction}\label{Intro::doc}\label{Intro:personis-user-modeling-framework}\begin{itemize}
\item {} 
User Models as first class citizens
\begin{itemize}
\item {} 
independant of a particular application

\item {} 
not just fragments of me locked away in individual systems

\item {} 
may be distributed over machines I use or in the cloud (could be a personal cloud)

\end{itemize}

\item {} 
Scutability and user control
\begin{itemize}
\item {} 
I own my model

\item {} 
I control what goes in

\item {} 
I control what goes out (releasing parts to applications)

\item {} 
I can see my model in meaningful forms

\end{itemize}

\item {} 
as new evidence about an aspect is available an application (evidence source) \emph{tells} the user model

\item {} 
the user model \emph{accretes} the evidence
\begin{itemize}
\item {} 
a times stamp is added

\item {} 
the source (registered name of the application) is added

\item {} 
the evidence type (explicit,...) is added

\item {} 
the evidence is appended to a list associated with a component of the model

\end{itemize}

\end{itemize}

Resolution:
\begin{itemize}
\item {} 
When an application needs to know information from the model, it asks the model for the value of the required set of components, it \emph{asks} the model for the required set of components

\item {} 
At that time
\begin{itemize}
\item {} 
A filter selects the evidence allowed to the asker

\item {} 
A resolver function interprets the allowed evidence
\begin{itemize}
\item {} 
the application may specify the resolver function (from those allowed)

\item {} 
Or use default

\item {} 
Can be very simple (eg Point Query) or arbitrarily sophisticated (eg use Bayesian model, ontology.)

\end{itemize}

\end{itemize}

\item {} 
Embrace inconsistency, multiple interpretations!

\end{itemize}

Scrutability:
\begin{description}
\item[{Definition:}] \leavevmode\begin{quote}

Capable of being understood through study and observation, comprehensible.
(www.thefreedictionary.com/scrutable)

Understandable upon close examination. (www.tiscali.co.uk/reference/dictionaries/difficultwords/data/d0011288.html)
\end{quote}
\begin{itemize}
\item {} 
the Personis Framework is designed for scrutability
\begin{itemize}
\item {} 
Why did the system adapt that way?

\item {} 
Where does the system think I am, and why?

\item {} 
Historic queries: what location did the system think I was on May 1st 2001?

\item {} 
what music does the system think I like and why?

\end{itemize}

\end{itemize}

\end{description}

Model Structure:
\begin{itemize}
\item {} 
the model is represented as a tree

\item {} 
we call the branches \emph{contexts} and the leaves \emph{components}

\end{itemize}

\includegraphics{model-tree.jpg}

Atomic modelled unit - component:

The components of a model contain the evidence associated with that attribute. Example components:
\begin{itemize}
\item {} 
for classic user model:
\begin{itemize}
\item {} 
knowledge

\item {} 
beliefs

\item {} 
preferences

\end{itemize}

\item {} 
for pervasive computing:
\begin{itemize}
\item {} 
attributes (eg weight, location, sensor reading)

\item {} 
qualifiers for knowledge and attributes

\item {} 
goals (eg I want to be able to do 10 chin-ups)

\end{itemize}

\end{itemize}
\begin{description}
\item[{Operation:}] \leavevmode\begin{quote}

tell
\end{quote}
\begin{itemize}
\item {} 
evidence is accreted by components after the \emph{tell} operation

\end{itemize}

\end{description}

\includegraphics{accretion.jpg}
\begin{description}
\item[{Operation:}] \leavevmode\begin{quote}

ask
\end{quote}
\begin{itemize}
\item {} 
A component value is retrieved from the nodel using an \emph{ask} operation
\begin{itemize}
\item {} 
the evidence is \emph{resolved} by a resolver function to give the value

\end{itemize}

\end{itemize}

\end{description}

\includegraphics{resolution.jpg}

Accretion/Resolution
\begin{itemize}
\item {} 
values are only calculated from the evidence when they are needed, rather than whenever a new data point (evidence) is received

\item {} 
the choice of resolver function allows flexibility in the calculated values. For example, location may be resolved as:
\begin{itemize}
\item {} 
room 123, or ``at work'', or latitude/longitude

\end{itemize}

\item {} 
historic queries are possible: where was I on a certain date, how have my music preferences changed.

\end{itemize}


\chapter{Documentation}
\label{Documentation:documentation}\label{Documentation::doc}
The documentation for Personis is built using the \emph{sphinx}, a python based documentation generation tool.
Sphinx can make the documentation in many forms.
To use the tool you need to install sphinx and its dependancies.
A generated pdf version is included in the distribution.
If you want to make the pdf version you will need to install a full latex package (eg texlive-full).

To make the various versions the command is:

\begin{DUlineblock}{0em}
\item[] make html
\item[] make latexpdf
\item[] make epub
\end{DUlineblock}

The generated versions are placed in the subdirectory ``\_build''.


\chapter{Installation}
\label{Installation:installation}\label{Installation::doc}
These installation instructions assume that you are installing Personis on a linux system with Python 2.6 or 2.7
installed.

The Personis framework makes use of several packages that are not part
of the default Python installation.
The packages are:

pip install cherrypy google-api-python-client pyyaml shove genshi sqlalchemy

Personis is known to work with these versions and copies are included in
the Personis distribution for your convenience. Personis may work with
more recent versions but this has not been tested.

Quick installation instructions:

The distribution of personis is a compressed tar file: Personis-rrr.tgz

First untar the distribution (\emph{rrr} is the release number):

\begin{Verbatim}[commandchars=\\\{\}]
\$ tar zxf Personis-rrr.tgz
\end{Verbatim}

This will create a directory Personis-rrr for the code:

\begin{Verbatim}[commandchars=\\\{\}]
\$ cd Personis-rrr
\$ ls
Apps            Personis        README          install.sh
\end{Verbatim}

To install Personis, use the command:

\begin{Verbatim}[commandchars=\\\{\}]
\$ ./install.sh
\end{Verbatim}

The Personis modules are in the Personis/Src directory and can be run directly
from that directory or any other directory by setting your PYTHONPATH
environment variable.
Necessary support packages will be installed in the Personis/lib/python
directory and so that directory must also be in the PYTHONPATH.

The following commands will set the path (where \emph{rrr} is the release number):

\begin{Verbatim}[commandchars=\\\{\}]
cd Personis-rrr
export PYTHONPATH={}`pwd{}`/Personis/Src:{}`pwd{}`/Personis/lib/python
\end{Verbatim}

You might want to note the value of PYTHONPATH and add a line to
your .bashrc to set it for future use.


\chapter{Tests}
\label{Tests:tests}\label{Tests::doc}
The test scripts are divided into those that test the base Personis
module for models stored on the local machine (base), and those that
test the server Personis module for models accessed via a network
connection (server). In both cases the driver test script gives you the
option of nominating a directory to store test models. In the base case
the models are accessed directly by the methods in the Personis\_base
module. In the server case, a Personis server is started to provide
access to the models.

To run the tests, change into the Personis directory and:

\begin{Verbatim}[commandchars=\\\{\}]
\$ bash Tests/base-tests
PYTHONPATH is ....../Personis/Src
model directory? [..../Tests/Models]
\end{Verbatim}

at this point the test script is asking for a directory to store the test models. The default directory
is ``Models'' in the Tests directory. You can accept this default by pressing return, or type another pathname.

You are now given the option of removing any models previously placed in the test directory. This is useful if
you want to rerun the tests from scratch and create the models again. If you press return you will get
the default response of ``No'', typing ``Y'' will remove the existing models:

\begin{Verbatim}[commandchars=\\\{\}]
Remove models in ......./Src/models? [N]
\end{Verbatim}

If you say Yes (or when you run it for the first time) the models will be recreated.
This will produce a lot of output showing all the model parts as they are created.

Next you are given the option of running all the available base tests, running a particular test, or no tests.
The base test scripts are stored in the directory Tests/Base and are numbered. If you are testing a particular
feature you can type the number, but to start we suggest typing return for all tests.
The tests now run, one a time, waiting for you to press return before starting the next. If you want to stop
you can press Control-C:

\begin{Verbatim}[commandchars=\\\{\}]
Test number? (CR for all, ctrl-C if none)

Running tests...

====================================================================
                          Tests/Base/example01\_add.py
====================================================================
add evidence to alice's model
===================================================================
Now check the evidence list for alice's names
===================================================================
Component:  First name
===================================================================


        ...lots more output...


=================
All Done.
=================
\end{Verbatim}

There should be only a small number of python error messages and these will have some explanation in the output.

There are a set of similar tests for the server that can be run with the command:

\begin{Verbatim}[commandchars=\\\{\}]
\$ bash Tests/server-tests

        ...lots of output...

=================
All Done.
=================
\end{Verbatim}

The models are created in a similar way for the server tests but a server process is started and the
client-server protocol used to access them. The server test scripts can be found in Tests/Server.


\chapter{Tutorial Introduction to Personis}
\label{Tutorial::doc}\label{Tutorial:tutorial-introduction-to-personis}
This tutorial assumes you have installed the framework using the instructions in the Installation section.
But as a quick recap for installing the client only:

Create a sandbox directory (u:\textbackslash{}comp5047, perhaps). Download \href{https://raw.github.com/pypa/virtualenv/master/virtualenv.py}{https://raw.github.com/pypa/virtualenv/master/virtualenv.py} to the directory. Create a python sandbox:

\begin{Verbatim}[commandchars=\\\{\}]
u:
cd \PYGZbs{}comp5047
c:\PYGZbs{}python2.6\PYGZbs{}python.exe virtualenv.py .
\end{Verbatim}

Install necessary libraries:

\begin{Verbatim}[commandchars=\\\{\}]
u:\PYGZbs{}comp5047\PYGZbs{}Scripts\PYGZbs{}pip install google-api-python-client pyyaml personis
\end{Verbatim}

Install the client examples from \href{https://github.com/downloads/jbu/personis/clients.zip}{https://github.com/downloads/jbu/personis/clients.zip}

Using the \emph{umbrowser} command line utility, the tutorial will take you through the construction, navigation and
management of a user model.


\section{umbrowser}
\label{Tutorial:umbrowser}
The umbrowser.py program is a commandline utility that allows most
operations of the Personis system to be carried out interactively.

Umbrowser is found in the clients/browser directory of the personis package and is started with
the command ./umbrowser.py (unix):

\begin{Verbatim}[commandchars=\\\{\}]
\$ ./umbrowser.py
\end{Verbatim}

or for windows:

\begin{Verbatim}[commandchars=\\\{\}]
u:
cd \PYGZbs{}comp5047
\PYGZbs{}comp5047\PYGZbs{}Scripts\PYGZbs{}python.exe umbrowser.py
\end{Verbatim}

The first time you run umbrowser it opens a web browser tab and goes through a login sequence. Usually two screens are presented: one at google that asks you to verify your identity, and one at the personis server asking whether you want to allow umbrowser access to your model (the correct answer is `yes'). If this is the first time accessing your model, one will be created for you. At the end of this you should end up at a prompt:

\begin{Verbatim}[commandchars=\\\{\}]
[''] \textgreater{}
\end{Verbatim}

The prompt indicates that the browser is waiting for a command. The
initial part shows the current context, with the root context as an
empty string.

The help command gives information about the available commands:

\begin{Verbatim}[commandchars=\\\{\}]
[''] \textgreater{} help
Documented commands (type help \textless{}topic\textgreater{}):
========================================
app         delapp        export      login        mkmodel  set       subscribe
attributes  delcomponent  import      ls           model    setgoals  tell
base        delsub        importmdef  mkcomponent  quit     setperm
cd          do            listapps    mkcontext    server   showperm

Undocumented commands:
======================
help
\end{Verbatim}

Now we can see what is in the model:

\begin{Verbatim}[commandchars=\\\{\}]
[''] \textgreater{} ls
Components:
Contexts: [u'Devices', u'Personal', u'Apps', u'Goals']
Views: \PYGZob{}\PYGZcb{}
Subscriptions: \PYGZob{}\PYGZcb{}
\end{Verbatim}

The ``ls'' command is a like the Unix ls command: it lists what is in the
current context.
As you can see, the model is empty - no components, contexts, views or
subscriptions.
So let's make a new context called ``Prefs'' in the current (root) context:

\begin{Verbatim}[commandchars=\\\{\}]
[''] \textgreater{} mkcontext Prefs
Context description? My preferences
Create new context 'Prefs' in context '['']' with description 'My preferences'
Ok?[N] Y

[''] \textgreater{} ls
Components:
Contexts: [u'Devices', u'Personal', u'Apps', u'Goals', u'Prefs']
Views: \PYGZob{}\PYGZcb{}
Subscriptions: \PYGZob{}\PYGZcb{}
\end{Verbatim}

Now we will change context to the new ``Prefs'' context and make a
component ``food'' for our food preferences:

\begin{Verbatim}[commandchars=\\\{\}]
[''] \textgreater{} cd Prefs

['', 'Prefs'] \textgreater{} mkcomponent food
Component description? type of food I prefer
Component type:
0 attribute
1 activity
2 knowledge
3 belief
4 preference
5 goal
Index? 4
Value type:
0 string
1 number
2 boolean
3 enum
4 JSON
Index? 0
Creating new component 'food', type 'preference', description 'type of food I prefer', value type 'string'
Ok?[N] Y

['', 'Prefs'] \textgreater{} ls
Components:
        food: type of food I prefer
Contexts: []
Views: \PYGZob{}\PYGZcb{}
Subscriptions: \PYGZob{}\PYGZcb{}

['', 'Prefs'] \textgreater{}
\end{Verbatim}

Now we have a model owned by you that has one
context ``Prefs'' containing one component ``food''.
Now, imagine that you like Thai food so we will add some evidence to your food
preference component using the ``tell'' command:

\begin{Verbatim}[commandchars=\\\{\}]
['', 'Prefs'] \textgreater{} tell food
Value? Thai
Evidence type:
0 explicit
1 implicit
2 exmachina
3 inferred
4 stereotype
Index? [0]
Evidence flag? (CR for none)
Tell value=Thai, type=explicit, flags=[], source=alice, context=['', 'Prefs'], component=food
Ok?[N] Y


['', 'Prefs'] \textgreater{} ls
Components:
        food: type of food I prefer
Contexts: []
Views: \PYGZob{}\PYGZcb{}
Subscriptions: \PYGZob{}\PYGZcb{}
\end{Verbatim}

We can now examine the ``food'' component with the ``ls'' command:

\begin{Verbatim}[commandchars=\\\{\}]
['', 'Prefs'] \textgreater{} ls food
===================================================================
Component:  type of food I prefer
===================================================================
showobj:
[...]
  value = Thai
[...]
---------------------------------
Evidence about it
---------------------------------
showobj:
        [...]
---------------------------------
\end{Verbatim}

Try doing the ``tell'' operation again with a different food preference and then ``ls food'' to see the additional
evidence that has been accreted.

To quit the model browser, use the \emph{quit} command.


\section{Logger}
\label{Tutorial:logger}
On a web browser (your phone will do) go to \href{http://personislog.appspot.com/}{http://personislog.appspot.com/}. Here you will be able to log some activity like eating some fruit. Click on one of the icons to log an activity. Now, let's see what happened to your model.

Start umbrowser, as in the previous section:

\begin{Verbatim}[commandchars=\\\{\}]
\$ ./umbrowser.py
Welcome James
Personis Model Browser
[''] \textgreater{} ls
Components:
Contexts: [u'Devices', u'Personal', u'Apps', u'Prefs']
Views: \PYGZob{}\PYGZcb{}
Subscriptions: \PYGZob{}\PYGZcb{}
[''] \textgreater{} cd Apps
['', 'Apps'] \textgreater{} ls
Components:
Contexts: [u'Logging']
Views: \PYGZob{}\PYGZcb{}
Subscriptions: \PYGZob{}\PYGZcb{}
['', 'Apps'] \textgreater{} cd Logging
['', 'Apps', 'Logging'] \textgreater{} ls
Components:
        logged\_items: All the items logged
Contexts: []
Views: \PYGZob{}\PYGZcb{}
Subscriptions: \PYGZob{}\PYGZcb{}
['', 'Apps', 'Logging'] \textgreater{}
['', 'Apps', 'Logging'] \textgreater{} ls logged\_items
\end{Verbatim}

How did we do this? You can find the source for the logging app, and other personis clients, at \href{https://github.com/jbu/personis/tree/master/clients/}{https://github.com/jbu/personis/tree/master/clients/} (log-llum is the cherrypy version, aelog is the version that runs on appengine). Look at the method log\_me in \href{https://github.com/jbu/personis/blob/master/clients/log-llum/log-llum.py}{https://github.com/jbu/personis/blob/master/clients/log-llum/log-llum.py}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@cherrypy.expose}
\PYG{k}{def} \PYG{n+nf}{log\PYGZus{}me}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{item}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{cherrypy}\PYG{o}{.}\PYG{n}{session}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{um}\PYG{l+s}{'}\PYG{p}{)} \PYG{o}{==} \PYG{n+nb+bp}{None}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n}{cherrypy}\PYG{o}{.}\PYG{n}{HTTPError}\PYG{p}{(}\PYG{l+m+mi}{400}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{Log in first.}\PYG{l+s}{'}\PYG{p}{)}
    \PYG{n}{um} \PYG{o}{=} \PYG{n}{cherrypy}\PYG{o}{.}\PYG{n}{session}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{um}\PYG{l+s}{'}\PYG{p}{)}
    \PYG{n}{ev} \PYG{o}{=} \PYG{n}{client}\PYG{o}{.}\PYG{n}{Evidence}\PYG{p}{(}\PYG{n}{source}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{llum-log}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{evidence\PYGZus{}type}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{explicit}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{value}\PYG{o}{=}\PYG{n}{item}\PYG{p}{,} \PYG{n}{time}\PYG{o}{=}\PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{um}\PYG{o}{.}\PYG{n}{tell}\PYG{p}{(}\PYG{n}{context}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{Apps}\PYG{l+s}{'}\PYG{p}{,}\PYG{l+s}{'}\PYG{l+s}{Logging}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{,} \PYG{n}{componentid}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{logged\PYGZus{}items}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{evidence}\PYG{o}{=}\PYG{n}{ev}\PYG{p}{)}
    \PYG{k}{raise} \PYG{n}{cherrypy}\PYG{o}{.}\PYG{n}{HTTPRedirect}\PYG{p}{(}\PYG{l+s}{'}\PYG{l+s}{/}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}

As you can see, the work is done by two lines. One creates the evidence that something happened, and the next tells the model about it.
We will now do a similar exercise.
\begin{itemize}
\item {} 
Create a new directory (u:\textbackslash{}comp5047\textbackslash{}asker).

\item {} 
Save \href{https://raw.github.com/jbu/personis/master/clients/asker/client\_secrets.json}{https://raw.github.com/jbu/personis/master/clients/asker/client\_secrets.json} into the new directory.

\item {} 
Copy this code skeleton into a file in the directory called ask.py:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{personis} \PYG{k+kn}{import} \PYG{n}{client}
\PYG{k+kn}{import} \PYG{n+nn}{httplib2}
\PYG{n}{p} \PYG{o}{=} \PYG{n}{httplib2}\PYG{o}{.}\PYG{n}{ProxyInfo}\PYG{p}{(}\PYG{n}{proxy\PYGZus{}type}\PYG{o}{=}\PYG{n}{httplib2}\PYG{o}{.}\PYG{n}{socks}\PYG{o}{.}\PYG{n}{PROXY\PYGZus{}TYPE\PYGZus{}HTTP\PYGZus{}NO\PYGZus{}TUNNEL}\PYG{p}{,} \PYG{n}{proxy\PYGZus{}host}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{www-cache.it.usyd.edu.au}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{proxy\PYGZus{}port}\PYG{o}{=}\PYG{l+m+mi}{8000}\PYG{p}{)}
\PYG{n}{um} \PYG{o}{=} \PYG{n}{client}\PYG{o}{.}\PYG{n}{util}\PYG{o}{.}\PYG{n}{LoginFromClientSecrets}\PYG{p}{(}\PYG{n}{http}\PYG{o}{=}\PYG{n}{httplib2}\PYG{o}{.}\PYG{n}{Http}\PYG{p}{(}\PYG{n}{proxy\PYGZus{}info}\PYG{o}{=}\PYG{n}{p}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

\end{itemize}

If we execute it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZbs{}comp5047\PYGZbs{}Scripts\PYGZbs{}python.exe ask.py
\end{Verbatim}

it should take you through an authentication routine (involving web browsers, google, and a personis server) and then exit.

Lets say we want to ask the model what we have been eating (assuming we have been logging our meals with the logging app shown above):

\begin{Verbatim}[commandchars=\\\{\}]
  kiwi : ***
 grape : *
 apple : **
  pear : ****
orange : ***
banana : *
\end{Verbatim}

Can you add to ask.py to replicate this? You will probably need to use umbrowser to discover the model structure.


\chapter{Personis Server}
\label{Server::doc}\label{Server:personis-server}
Personis operates as a library that is imported by application programs and stores models in the local file
system.

Personis can also be run as a server, providing an interface to models for remote clients. In this case the API is almost the same, the only difference being the modules that is imported and used for the Access call, and the
specification of the model to be accessed.

In the case of locally stored models, access requires a \emph{modeldir} argument to specify the
location of the stored models, as well as the name of the model (a simple ID).
For models accessed remotely via the server, \emph{modeldir} is not used and the model name has the form:
name@server{[}:port{]}.

For example, to access the model for ``alice'' stored on the server ``models.server.com'' we
would use the statements:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{Personis}

\PYG{n}{um} \PYG{o}{=} \PYG{n}{Personis}\PYG{o}{.}\PYG{n}{Access}\PYG{p}{(}\PYG{n}{model}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{alice@models.server.com}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{user}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{myapp}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{password}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{pass}\PYG{l+s}{'}\PYG{p}{)}
\end{Verbatim}


\section{Running a Server}
\label{Server:running-a-server}
It is very easy to run your own Personis server to provide access to models for remote clients.

A server gets configuration information from the file \$HOME/.personis\_server.conf.
This file specifies the port that the server is to use as well as some miscellaneous configuration options.
A suitable personis\_server.conf file can be found in the Personis/Src directory. This can be copied into
\$HOME/.personis\_server.conf and the port number changed as desired.

A server can be started for any set of models stored in the same directory using the command:

\begin{Verbatim}[commandchars=\\\{\}]
\# assuming that PYTHONPATH, MODELDIR and LOGFILE are initialised
Personis.py  --models \$MODELDIR --log \$LOGFILE \&
\end{Verbatim}

The directory containing the models is specified in \$MODELDIR.
Log information is written to \$LOGFILE. This includes information on all requests, error messages etc.


\chapter{Example Applications}
\label{Examples::doc}\label{Examples:example-applications}

\section{Museum Guide}
\label{Examples:museum-guide}

\section{Health Monitoring}
\label{Examples:health-monitoring}

\section{Drill and Practice}
\label{Examples:drill-and-practice}

\chapter{Application Program Interface}
\label{API:application-program-interface}\label{API::doc}
\textbf{Files}

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{
File
} & \textbf{
Description
}\\\hline

base.py
 & 
the core library that accesses models in local directories/files
\\\hline

active.py
 & 
adds `Active User Models' to Personis. This allows components to
be `subscribable' and statements in a simple language to be
executed when new component values satisfy a condition.
\\\hline

server.py
 & 
a server and set of stubs for the server version of Personis
uses active.py to do the work
\\\hline

tests/*
 & 
scripts to test the system
\\\hline

mkmodel
 & 
utility program to make a set of models from a
\\\hline

modeldef
 & 
definition file
\\\hline
\end{tabulary}

\phantomsection\label{API:module-personis.client}\index{personis.client (module)}\index{Access (class in personis.client)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access}\pysiglinewithargsret{\strong{class }\code{personis.client.}\bfcode{Access}}{\emph{model='-`}, \emph{connection=None}, \emph{uri=None}, \emph{credentials=None}, \emph{http=None}, \emph{loglevel=20}, \emph{test=True}}{}
Client version of access for client/server system
\begin{description}
\item[{arguments:}] \leavevmode
model           model name
modelserver     model server and port
user            user name
password        password string

\end{description}

returns a user model access object
\index{ask() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access.ask}\pysiglinewithargsret{\bfcode{ask}}{\emph{context=}\optional{}, \emph{view=None}, \emph{resolver=None}, \emph{showcontexts=None}}{}~\begin{description}
\item[{arguments: (see Personis\_base for details)}] \leavevmode
context is a list giving the path of context identifiers
view is either:
\begin{quote}

an identifier of a view in the context specified
a list of component identifiers or full path lists
None indicating that the values of all components in
\begin{quote}

the context be returned
\end{quote}
\end{quote}

resolver specifies a resolver, default is the builtin resolver

\end{description}

returns a list of component objects

\end{fulllineitems}

\index{delcomponent() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access.delcomponent}\pysiglinewithargsret{\bfcode{delcomponent}}{\emph{context=}\optional{}, \emph{componentid=None}}{}
Delete an existing component in a given context
arguments:
\begin{quote}

context - a list giving the path to the required context
id - the id for a componen
\end{quote}
\begin{description}
\item[{returns:}] \leavevmode
None on success
a string error message on error

\end{description}

\end{fulllineitems}

\index{delcontext() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access.delcontext}\pysiglinewithargsret{\bfcode{delcontext}}{\emph{context=}\optional{}}{}
Delete an existing context
arguments:
\begin{quote}

context - a list giving the path to the required context
\end{quote}
\begin{description}
\item[{returns:}] \leavevmode
None on success
a string error message on error

\end{description}

\end{fulllineitems}

\index{delete\_sub() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access.delete_sub}\pysiglinewithargsret{\bfcode{delete\_sub}}{\emph{context=}\optional{}, \emph{componentid=None}, \emph{subname=None}}{}
arguments:
context is a list giving the path of context identifiers
componentid designates the component subscribed to
subname is the subscription name

\end{fulllineitems}

\index{deleteapp() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access.deleteapp}\pysiglinewithargsret{\bfcode{deleteapp}}{\emph{app=None}}{}
deletes an app

\end{fulllineitems}

\index{delview() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access.delview}\pysiglinewithargsret{\bfcode{delview}}{\emph{context=}\optional{}, \emph{viewid=None}}{}
Delete an existing view in a given context
arguments:
\begin{quote}

context - a list giving the path to the required context
viewid - the id for the view
\end{quote}
\begin{description}
\item[{returns:}] \leavevmode
None on success

\end{description}

\end{fulllineitems}

\index{export\_model() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access.export_model}\pysiglinewithargsret{\bfcode{export\_model}}{\emph{context=}\optional{}, \emph{resolver=None}}{}
arguments:
context is the context to export
resolver is a string containing the name of a resolver
\begin{quote}

or
\end{quote}
\begin{description}
\item[{resolver is a dictionary containing information about resolver(s) to be used and arguments}] \leavevmode
the ``resolver'' key gives the name of a resolver to use, if not present the default resolver is used
the ``evidence\_filter'' key specifies an evidence filter
eg `evidence\_filter' =  ``all'' returns all evidence,
\begin{quote}

``last10'' returns last 10 evidence items,
``last1'' returns most recent evidence item,
None returns no evidence
\end{quote}

\end{description}

\end{fulllineitems}

\index{getcontext() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access.getcontext}\pysiglinewithargsret{\bfcode{getcontext}}{\emph{context=}\optional{}, \emph{getsize=False}}{}
Get context information
arguments:
\begin{quote}

context - a list giving the path to the required context
getsize - True if the size in bytes of the context subtree is required
\end{quote}

\end{fulllineitems}

\index{getpermission() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access.getpermission}\pysiglinewithargsret{\bfcode{getpermission}}{\emph{context=None}, \emph{componentid=None}, \emph{app=None}}{}
gets permissions for a context (if componentid is None) or
a component
returns a tuple (ask,tell)

\end{fulllineitems}

\index{getresolvers() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access.getresolvers}\pysiglinewithargsret{\bfcode{getresolvers}}{}{}
Return a list of the available resolver names

\end{fulllineitems}

\index{import\_model() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access.import_model}\pysiglinewithargsret{\bfcode{import\_model}}{\emph{context=}\optional{}, \emph{partial\_model=None}}{}
arguments:
context is the context to import into
partial\_model is a json encoded string containing the partial model

\end{fulllineitems}

\index{list\_subs() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access.list_subs}\pysiglinewithargsret{\bfcode{list\_subs}}{\emph{context=}\optional{}, \emph{componentid=None}}{}
arguments:
context is a list giving the path of context identifiers
componentid designates the component with subscriptions attached

\end{fulllineitems}

\index{listapps() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access.listapps}\pysiglinewithargsret{\bfcode{listapps}}{}{}
returns array of registered app names

\end{fulllineitems}

\index{mkcomponent() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access.mkcomponent}\pysiglinewithargsret{\bfcode{mkcomponent}}{\emph{context=}\optional{}, \emph{componentobj=None}}{}
Make a new component in a given context
arguments:
\begin{quote}

context - a list giving the path to the required context
componentobj - a Component object
\end{quote}
\begin{description}
\item[{returns:}] \leavevmode
None on success
a string error message on error

\end{description}

\end{fulllineitems}

\index{mkcontext() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access.mkcontext}\pysiglinewithargsret{\bfcode{mkcontext}}{\emph{context=}\optional{}, \emph{contextobj=None}}{}
Make a new context in a given context
arguments:
\begin{quote}

context - a list giving the path to the required context
contextobj - a Context object
\end{quote}

\end{fulllineitems}

\index{mkview() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access.mkview}\pysiglinewithargsret{\bfcode{mkview}}{\emph{context=}\optional{}, \emph{viewobj=None}}{}
Make a new view in a given context
arguments:
\begin{quote}

context - a list giving the path to the required context
viewobj - a View object
\end{quote}
\begin{description}
\item[{returns:}] \leavevmode
None on success
a string error message on error

\end{description}

\end{fulllineitems}

\index{registerapp() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access.registerapp}\pysiglinewithargsret{\bfcode{registerapp}}{\emph{app=None}, \emph{desc='`}, \emph{password=None}}{}
registers a password for an app
app name is a string (needs checking TODO)
app passwords are stored at the top level .model db

\end{fulllineitems}

\index{set\_goals() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access.set_goals}\pysiglinewithargsret{\bfcode{set\_goals}}{\emph{context=}\optional{}, \emph{componentid=None}, \emph{goals=None}}{}
arguments:
context is a list giving the path of context identifiers
componentid designates the component with subscriptions attached
goals is a list of paths to components that are:
\begin{quote}

goals for this componentid if it is not of type goal
components that contribute to this componentid if it is of type goal
\end{quote}

\end{fulllineitems}

\index{setpermission() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access.setpermission}\pysiglinewithargsret{\bfcode{setpermission}}{\emph{context=None}, \emph{componentid=None}, \emph{app=None}, \emph{permissions=\{\}}}{}
sets ask/tell permission for a context (if componentid is None) or
a component

\end{fulllineitems}

\index{setresolver() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access.setresolver}\pysiglinewithargsret{\bfcode{setresolver}}{\emph{context}, \emph{componentid}, \emph{resolver}}{}
set the resolver for a given component in a given context
arguments:
\begin{quote}

context - a list giving the path to the required context
componentid - the id for a given component
resolver - the id of the resolver
\end{quote}
\begin{description}
\item[{returns:}] \leavevmode
None on success
a string error message on error

\end{description}

\end{fulllineitems}

\index{subscribe() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access.subscribe}\pysiglinewithargsret{\bfcode{subscribe}}{\emph{context=}\optional{}, \emph{view=None}, \emph{subscription=None}}{}
arguments:
context is a list giving the path of context identifiers
view is either:
\begin{quote}

an identifier of a view in the context specified
a list of component identifiers or full path lists
None indicating that the values of all components in
\begin{quote}

the context be returned
\end{quote}

subscription is a Subscription object
\end{quote}

\end{fulllineitems}

\index{tell() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Access.tell}\pysiglinewithargsret{\bfcode{tell}}{\emph{context=}\optional{}, \emph{componentid=None}, \emph{evidence=None}}{}
arguments:
context - a list giving the path to the required context
componentid - identifier of the component
evidence - evidence object to add to the component

\end{fulllineitems}


\end{fulllineitems}

\index{Component (class in personis.client)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Component}\pysiglinewithargsret{\strong{class }\code{personis.client.}\bfcode{Component}}{\emph{**kargs}}{}
component object
Identifier  the identifier of the component
\begin{quote}

unique in the context
\end{quote}

Description readable description
creation\_time   time of creation of the component
component\_type  {[}''attribute'', ``activity'', ``knowledge'', ``belief'', ``preference'', ``goal''{]}
value\_type  {[}''string'', ``number'',''boolean'', ``enum'', ``JSON''{]}
value\_list    a list of strings that are the possible values for type ``enum''
value       the resolved value
resolver    default resolver for this component
goals       list of component paths eg {[} {[}'Personal', `Health', `weight'{]}, ...{]}
evidencelist    list of evidence objects

\end{fulllineitems}

\index{Context (class in personis.client)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Context}\pysiglinewithargsret{\strong{class }\code{personis.client.}\bfcode{Context}}{\emph{**kargs}}{}
context object
Identifier  the identifier of the component
\begin{quote}

unique in the context
\end{quote}

Description readable description
resolver    default resolver for components in this context

\end{fulllineitems}

\index{Evidence (class in personis.client)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Evidence}\pysiglinewithargsret{\strong{class }\code{personis.client.}\bfcode{Evidence}}{\emph{**kargs}}{}
evidence object
evidence\_type   ``explicit'', \# given by the user
\begin{quote}

``implicit'', \# observed by the machine
``exmachina'', \# told (to the user) by the machine
``inferred'', \# evidence generated by a subscription inference 
``stereotype''{]} \# evidence added by a stereotype
\end{quote}

source  string indicating source of evidence
value   any python object
comment string with extra information about the evidence
flags   a list of strings eg ``goal''
time    notional creation time optionally given by user
creation\_time actual time evidence item was created
useby   timestamp evidence expires (if required)
\index{EvidenceTypes (personis.client.Evidence attribute)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.Evidence.EvidenceTypes}\pysigline{\bfcode{EvidenceTypes}\strong{ = {[}'explicit', `implicit', `exmachina', `inferred', `stereotype'{]}}}
explicit: given by the user  (given)
implicit: observed by the machine (observation)
exmachina: told (to the user) by the machine (told)
inferred: evidence generated by inference (external or internal)
stereotype: evidence added by a stereotype

\end{fulllineitems}


\end{fulllineitems}

\index{View (class in personis.client)}

\begin{fulllineitems}
\phantomsection\label{API:personis.client.View}\pysiglinewithargsret{\strong{class }\code{personis.client.}\bfcode{View}}{\emph{**kargs}}{}
view object
Identifier  the identifier of the component
\begin{quote}

unique in the context
\end{quote}

Description readable description

\end{fulllineitems}


\textbf{Constants}

ComponentTypes:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s}{"}\PYG{l+s}{attribute}\PYG{l+s}{"}
\PYG{l+s}{"}\PYG{l+s}{activity}\PYG{l+s}{"}
\PYG{l+s}{"}\PYG{l+s}{knowledge}\PYG{l+s}{"}
\PYG{l+s}{"}\PYG{l+s}{belief}\PYG{l+s}{"}
\PYG{l+s}{"}\PYG{l+s}{preference}\PYG{l+s}{"}
\PYG{l+s}{"}\PYG{l+s}{goal}\PYG{l+s}{"}
\end{Verbatim}

ValueTypes:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s}{"}\PYG{l+s}{string}\PYG{l+s}{"}
\PYG{l+s}{"}\PYG{l+s}{number}\PYG{l+s}{"}
\PYG{l+s}{"}\PYG{l+s}{boolean}\PYG{l+s}{"}
\PYG{l+s}{"}\PYG{l+s}{enum}\PYG{l+s}{"}
\PYG{l+s}{"}\PYG{l+s}{JSON}\PYG{l+s}{"}
\end{Verbatim}

EvidenceTypes:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s}{"}\PYG{l+s}{explicit}\PYG{l+s}{"}  \PYG{c}{\PYGZsh{} given by the user  (given)}
\PYG{l+s}{"}\PYG{l+s}{implicit}\PYG{l+s}{"}  \PYG{c}{\PYGZsh{} observed by the machine (observation)}
\PYG{l+s}{"}\PYG{l+s}{exmachina}\PYG{l+s}{"} \PYG{c}{\PYGZsh{} told (to the user) by the machine (told)}
\PYG{l+s}{"}\PYG{l+s}{inferred}\PYG{l+s}{"}  \PYG{c}{\PYGZsh{} evidence generated by inference (external or internal)}
\PYG{l+s}{"}\PYG{l+s}{stereotype}\PYG{l+s}{"} \PYG{c}{\PYGZsh{} evidence added by a stereotype}
\end{Verbatim}

\textbf{Functions}

\begin{DUlineblock}{0em}
\item[] MkModel(model=None, modeldir=None, user=None, password=None, description=None):
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] make a model with name ``model'' in directory modeldir for ``user''/''password'' with ``description''
\end{DUlineblock}
\end{DUlineblock}

\textbf{Classes}

\begin{Verbatim}[commandchars=\\\{\}]
Component: component object
        Identifier      the identifier of the component
                        unique in the context
        Description     readable description
        component\_type  ["attribute", "activity", "knowledge", "belief", "preference", "goal"]
        value\_type      ["string", "number","boolean", "enum", "JSON"]
        value\_list      a list of strings that are the possible values for type "enum"
        value           the resolved value
        resolver        default resolver for this component
        goals           list of component paths eg [ ['Personal', 'Health', 'weight'], ...]
        evidencelist    list of evidence objects

Evidence: evidence object
        evidence\_type   "explicit", \# given by the user
                        "implicit", \# observed by the machine
                        "exmachina", \# told (to the user) by the machine
                        "inferred", \# evidence generated by a subscription inference
                        "stereotype"] \# evidence added by a stereotype
        source  string indicating source of evidence
        value   any python object
        comment string with extra information about the evidence
        flags   a list of strings eg "goal"
        time    timestamp
        useby   timestamp evidence expires (if required)

Context: context object
        Identifier      the identifier of the component
                        unique in the context
        Description     readable description
        resolver        default resolver for components in this context

View: view object
        Identifier      the identifier of the component
                        unique in the context
        Description     readable description

Access(Resolvers.Access): user model object
        model           model name
        modeldir        model directory
        user            user name
        password        password string
returns a user model access object
\end{Verbatim}

Access methods:

\begin{Verbatim}[commandchars=\\\{\}]
def ask(self,  context=[], view=None, resolver=None, showcontexts=None):
        context is a list giving the path of context identifiers
        view is either:
                an identifier of a view in the context specified
                a list of component identifiers or full path lists
                None indicating that the values of all components in
                        the context be returned
        resolver is a string containing the name of a resolver
                or
        resolver is a dictionary containing information about resolver(s) to be used and arguments
                the "resolver" key gives the name of a resolver to use, if not present the default resolver is used
                the args may include a specified evidence filter
                eg 'evidence\_filter' =  "all" returns all evidence,
                                        "last10" returns last 10 evidence items,
                                        "last1" returns most recent evidence item,
                                        None returns no evidence
        showcontexts: if True, a tuple is returned containing
                (list of component objects,
                list of contexts in the current context,
                list of views in the current context,
                list of subscriptions in the current context)
        returns a list of component objects

def tell(self, context=[], componentid=None, evidence=None,   \# evidence obj dosubs=True):
        arguments:
                context - a list giving the path to the required context
                componentid - identifier of the component
                evidence - evidence object to add to the component

def export\_model(self,  context=[], evidence\_filter=None, level=None):
        context is a list giving the path of context identifiers
                this is the root of the um tree to export
        evidence\_filter specifies an evidence filter
                (partially implemented: "all" returns all evidence,
                                        "last10" returns last 10 evidence items,
                                        "last1" returns most recent evidence item,
                                        None returns no evidence)
        returns a JSON encoded representation of the um tree

def import\_model(self, context=[], partial\_model=None):
        arguments:
        context - context to import partial model to
                if None, use root of model
        partial\_model - string containing JSON representation of model dictionary
                OR
                a dictionary with elements:
                        contextinfo - Description, Identifier, perms, resolver
                        contexts - sub contexts
                        components
                        views
                        subs

def set\_goals(self, context=[], componentid=None, goals=None):
        set the goal list for a component
        requires "tell" permission
        arguments:
                context - a list giving the path to the required context
                componentid - identifier of the component
                goals - list of goal component paths

def mkcomponent(self, context=[], componentobj=None):
        Make a new component in a given context
        arguments:
                context - a list giving the path to the required context
                componentobj - a Component object
        returns:
                None on success
                a string error message on error

def delcomponent(self, context= [], componentid=None):
        Delete an existing component in a given context
        arguments:
                context - a list giving the path to the required context
                id - the id for a componen
        returns:
                None on success
                a string error message on error

def mkcontext(self, context= [], contextobj=None):
        Make a new context in a given context
        arguments:
                context - a list giving the path to the required context
                contextobj - a Context object
        return True if created ok, False otherwise

def delcontext(self, context=[]):
        Delete an existing context
        arguments:
                context - a list giving the path to the required context
        returns:
                None on success
                a string error message on error

def getcontext(self, context=[], getsize=False):
        get information (Description, size etc) of a context
        arguments:
                context - a list giving the path to the required context
                getsize - if True, return the size in bytes of the context subtree
        returns:
                None on success
                a string error message on error

def registerapp(self, app=None, desc="", password=None):
        registers a password for an app
        app name is a string (needs checking TODO)
        desc is the app description string
        app passwords are stored at the top level .model db
        returns a dictionary containing description and password(access key)

def deleteapp(self, app=None):
        deletes an app

def listapps(self):
        returns an dictionary of apps that are registered
        key is app name, 'description' is app description

def setpermission(self, context=None, componentid=None, app=None, permissions=\PYGZob{}\PYGZcb{}):
        sets ask/tell permission for a context (if componentid is None) or
                a component

def setresolver(self, context, componentid, resolver):

def getresolvers(self):

def mkview(self, context= [], viewobj=None):
        Make a new view in a given context
        arguments:
                context - a list giving the path to the required context
                viewobj - a View object

def delview(self, context=[], viewid=None):
        Delete an existing view within a given context
        arguments:
                context - a list giving the path to the required context
                viewid - view identifier
        returns:
                on success, None
                on failure, a string reporting the problem

def subscribe(context=[], view=None, subscription=None):
        add a subscription to the component specified by the context and view
        arguments:
                context - a list giving the path to the required context
                viewobj - a View object
                subscription - is a dictionary containing owner, password and subscription statement string
        returns a token that can be used to delete the subscription

def delete\_sub(context=[], componentid=None, subname=None):
        deletes a subscription specified by the token subname in the component specified by the context and componentid
        arguments:
                context - a list giving the path to the required context
                componentid - name of component in the context
                subname - a token return from the subscribe call when the subscription is installed
                                also available using an ask call with showcontexts=True
\end{Verbatim}


\section{Examples}
\label{API:examples}
Models can be accessed either locally in the filesystem, or via a server.

Local access is via the Personis\_base module.

\textbf{Basic accretion operation - tell some evidence}

The following example shows the use of Personis\_base to \emph{tell} a piece of evidence
containing a name string to a component in the model.  The source of the evidence is ``contactapp'' which will have
been given access to the model by the owner.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{Personis\PYGZus{}base}

\PYG{c}{\PYGZsh{} access the model in the filesystem}
\PYG{c}{\PYGZsh{} model name is "alice", model is stored in directory "Models"}
\PYG{n}{um} \PYG{o}{=} \PYG{n}{Personis\PYGZus{}base}\PYG{o}{.}\PYG{n}{Access}\PYG{p}{(}\PYG{n}{model}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{alice}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{modeldir}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{Models}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{user}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{contactapp}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{password}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{secret}\PYG{l+s}{'}\PYG{p}{)}

\PYG{c}{\PYGZsh{} create a piece of evidence with Alice as value}
\PYG{n}{ev} \PYG{o}{=} \PYG{n}{Personis\PYGZus{}base}\PYG{o}{.}\PYG{n}{Evidence}\PYG{p}{(}\PYG{n}{evidence\PYGZus{}type}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{explicit}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{value}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{Alice}\PYG{l+s}{"}\PYG{p}{)}

\PYG{c}{\PYGZsh{} tell this as user alice's first name into component "firstname", context "Personal"}
\PYG{n}{um}\PYG{o}{.}\PYG{n}{tell}\PYG{p}{(}\PYG{n}{context}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{Personal}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,} \PYG{n}{componentid}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{firstname}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{evidence}\PYG{o}{=}\PYG{n}{ev}\PYG{p}{)}
\end{Verbatim}

\textbf{Basic resolution operation - ask for a value}

This example {\color{red}\bfseries{}*}ask*s for the value of a component using the default resolver that uses the most recent piece of
evidence.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{Personis\PYGZus{}base}

\PYG{n}{um} \PYG{o}{=} \PYG{n}{Personis\PYGZus{}base}\PYG{o}{.}\PYG{n}{Access}\PYG{p}{(}\PYG{n}{model}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{alice}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{modeldir}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{Models}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{user}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{contactapp}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{password}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{secret}\PYG{l+s}{'}\PYG{p}{)}

\PYG{c}{\PYGZsh{} now ask for the value of the component using the default resolver and the last piece of evidence}
\PYG{n}{reslist} \PYG{o}{=} \PYG{n}{um}\PYG{o}{.}\PYG{n}{ask}\PYG{p}{(}\PYG{n}{context}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{Personal}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,} \PYG{n}{view}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{firstname}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,} \PYG{n}{resolver}\PYG{o}{=}\PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{evidence\PYGZus{}filter}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{last1}\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

A \emph{view} is just a list of components. The list can be explicit in the ask request or we can give a view a
name and store it in the model.

For example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} now ask for the value of two components using a view}
\PYG{n}{reslist} \PYG{o}{=} \PYG{n}{um}\PYG{o}{.}\PYG{n}{ask}\PYG{p}{(}\PYG{n}{context}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{Personal}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,} \PYG{n}{view}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{firstname}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{lastname}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,} \PYG{n}{resolver}\PYG{o}{=}\PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{evidence\PYGZus{}filter}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{last1}\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

We can make a view using a view object and the \emph{mkview} method. For example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{Personis\PYGZus{}base}

\PYG{n}{um} \PYG{o}{=} \PYG{n}{Personis\PYGZus{}base}\PYG{o}{.}\PYG{n}{Access}\PYG{p}{(}\PYG{n}{model}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{alice}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{modeldir}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{Models}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{user}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{contactapp}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{password}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{secret}\PYG{l+s}{'}\PYG{p}{)}

\PYG{n}{vobj} \PYG{o}{=} \PYG{n}{Personis\PYGZus{}base}\PYG{o}{.}\PYG{n}{View}\PYG{p}{(}\PYG{n}{Identifier}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{fullname}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{component\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{firstname}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{lastname}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{um}\PYG{o}{.}\PYG{n}{mkview}\PYG{p}{(}\PYG{n}{context}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{Personal}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,} \PYG{n}{viewobj}\PYG{o}{=}\PYG{n}{vobj}\PYG{p}{)}

\PYG{n}{reslist}\PYG{o}{=} \PYG{n}{um}\PYG{o}{.}\PYG{n}{ask}\PYG{p}{(}\PYG{n}{context}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{Personal}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,} \PYG{n}{view} \PYG{o}{=} \PYG{l+s}{'}\PYG{l+s}{fullname}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{resolver}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{evidence\PYGZus{}filter}\PYG{l+s}{'}\PYG{p}{:}\PYG{l+s}{"}\PYG{l+s}{all}\PYG{l+s}{"}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\end{Verbatim}

The values are returned by an ask request in a list of component objects, one for eachc component value requested.
The component objects have the attributes described in the documentation above but this includes
a \emph{value} attribute  which is the resolved value for the component. Eg:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{reslist} \PYG{o}{=} \PYG{n}{um}\PYG{o}{.}\PYG{n}{ask}\PYG{p}{(}\PYG{n}{context}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{Personal}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,} \PYG{n}{view}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{firstname}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,} \PYG{n}{resolver}\PYG{o}{=}\PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{evidence\PYGZus{}filter}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{last1}\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Firstname:}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{reslist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{value}
\end{Verbatim}

\textbf{Creating new contexts and components}

The \emph{mkcontext} and \emph{mkcomponent} methods, along with the \emph{Component} and \emph{Context} objects, are used to build
new elements in the model. Here is an example of creating and then deleting a context:

\begin{Verbatim}[commandchars=\\\{\}]
\# assume we have accessed the model
print "creating context 'Deltest' in context 'Personal'"
cobj = Personis\_base.Context(Identifier="Deltest", Description="testing context deletion")
\# now make the new context
um.mkcontext(context=["Personal"], contextobj=cobj)

print "now delete it"
um.delcontext(context=["Personal", "Deltest"]):
\end{Verbatim}

and here is an example of creating and then deleting a component:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cobj} \PYG{o}{=} \PYG{n}{Personis\PYGZus{}base}\PYG{o}{.}\PYG{n}{Component}\PYG{p}{(}\PYG{n}{Identifier}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{age}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{component\PYGZus{}type}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{attribute}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{Description}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{age}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{goals}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{Personal}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{Health}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{weight}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{value\PYGZus{}type}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{number}\PYG{l+s}{"}\PYG{p}{)}

\PYG{n}{um}\PYG{o}{.}\PYG{n}{mkcomponent}\PYG{p}{(}\PYG{n}{context}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{Personal}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,} \PYG{n}{componentobj}\PYG{o}{=}\PYG{n}{cobj}\PYG{p}{)}

\PYG{c}{\PYGZsh{} tell some evidence to the new component}
\PYG{n}{ev} \PYG{o}{=} \PYG{n}{Personis\PYGZus{}base}\PYG{o}{.}\PYG{n}{Evidence}\PYG{p}{(}\PYG{n}{evidence\PYGZus{}type}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{explicit}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{value}\PYG{o}{=}\PYG{l+m+mi}{17}\PYG{p}{)}
\PYG{n}{um}\PYG{o}{.}\PYG{n}{tell}\PYG{p}{(}\PYG{n}{context}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{Personal}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,} \PYG{n}{componentid}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{age}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{evidence}\PYG{o}{=}\PYG{n}{ev}\PYG{p}{)}
\PYG{n}{reslist} \PYG{o}{=} \PYG{n}{um}\PYG{o}{.}\PYG{n}{ask}\PYG{p}{(}\PYG{n}{context}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{Personal}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,} \PYG{n}{view}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{age}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{,} \PYG{n}{resolver}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{evidence\PYGZus{}filter}\PYG{l+s}{'}\PYG{p}{:}\PYG{l+s}{"}\PYG{l+s}{all}\PYG{l+s}{"}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Age:}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{reslist}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{value}

\PYG{c}{\PYGZsh{} delete the component}
\PYG{n}{resd} \PYG{o}{=} \PYG{n}{um}\PYG{o}{.}\PYG{n}{delcomponent}\PYG{p}{(}\PYG{n}{context}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{Personal}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,} \PYG{n}{componentid} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{age}\PYG{l+s}{"}\PYG{p}{)}
\end{Verbatim}

\textbf{Navigating the Model}

If you want to discover what contexts are present in the model there is a variant on the \emph{ask} method that
allows you to get a list of all the \emph{contexts}, \emph{components}, \emph{views} and \emph{subscriptions} that are
contained in a given context. Just add the parameter ``showcontexts=True'' to the \emph{ask} call.
Using this call you can start at the root context and walk the tree of contexts discovering the full
contents of the model. Eg:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Show the root context}\PYG{l+s}{"}
\PYG{n}{info} \PYG{o}{=} \PYG{n}{um}\PYG{o}{.}\PYG{n}{ask}\PYG{p}{(}\PYG{n}{context}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,} \PYG{n}{showcontexts}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\end{Verbatim}

The return value is a tuple containing (componentlist, contextlist, viewlist, sublist), where each part
of the tuple is a list of objects.

\textbf{Subscriptions: rules for action}

A feature of Personis is the ability to add a rule to a component that is examined when ever a \emph{tell} operation
is performed on the component. The rule typically examines a resolved value of the component, matching against a
pattern. If the pattern is matched an action is initiated. The action can be a \emph{tell} operation to tell some
evidence to a component, or a \emph{notify} operation that will construct a URL and fetch it, thus initiating some
action at an external web site.  Rules can be deleted using the \emph{delete\_sub} method.

Note that you need to use Personis\_a instead of Personis\_base as that is where the subscription methods are found.

For example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{Personis\PYGZus{}base}
\PYG{k+kn}{import} \PYG{n+nn}{Personis\PYGZus{}a}

\PYG{n}{um} \PYG{o}{=} \PYG{n}{Personis\PYGZus{}a}\PYG{o}{.}\PYG{n}{Access}\PYG{p}{(}\PYG{n}{model}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{alice}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{modeldir}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{Models}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{user}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{contactapp}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{password}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{secret}\PYG{l+s}{'}\PYG{p}{)}

\PYG{c}{\PYGZsh{} subscription rule that will match firstname against a wildcard pattern (regular expression):}
\PYG{n}{sub} \PYG{o}{=} \PYG{l+s}{"""}
\PYG{l+s}{\textless{}default!./Personal/firstname\textgreater{} \PYGZti{} }\PYG{l+s}{'}\PYG{l+s}{.*}\PYG{l+s}{'}\PYG{l+s}{ :}
\PYG{l+s}{         NOTIFY }\PYG{l+s}{'}\PYG{l+s}{http://www.myweb.me/\PYGZti{}alice/action.cgi?}\PYG{l+s}{'}\PYG{l+s}{ }\PYG{l+s}{'}\PYG{l+s}{firstname=}\PYG{l+s}{'}\PYG{l+s}{ \textless{}./Personal/firstname\textgreater{}}
\PYG{l+s}{"""}

\PYG{c}{\PYGZsh{} a token identifying the rule is returned}
\PYG{n}{subtoken} \PYG{o}{=} \PYG{n}{um}\PYG{o}{.}\PYG{n}{subscribe}\PYG{p}{(}\PYG{n}{context}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{Personal}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,} \PYG{n}{view}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{firstname}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{,} \PYG{n}{subscription}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{user}\PYG{l+s}{'}\PYG{p}{:}\PYG{l+s}{'}\PYG{l+s}{alice}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{password}\PYG{l+s}{'}\PYG{p}{:}\PYG{l+s}{'}\PYG{l+s}{secret}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{statement}\PYG{l+s}{'}\PYG{p}{:}\PYG{n}{sub}\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{n}{ev} \PYG{o}{=} \PYG{n}{Personis\PYGZus{}base}\PYG{o}{.}\PYG{n}{Evidence}\PYG{p}{(}\PYG{n}{evidence\PYGZus{}type}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{explicit}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{value}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{Alice}\PYG{l+s}{"}\PYG{p}{)}
\PYG{c}{\PYGZsh{} do a tell. This should cause the action.cgi script to be invoked with the firstame}
\PYG{n}{um}\PYG{o}{.}\PYG{n}{tell}\PYG{p}{(}\PYG{n}{context}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{Personal}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,} \PYG{n}{componentid}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{firstname}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{evidence}\PYG{o}{=}\PYG{n}{ev}\PYG{p}{)}

\PYG{c}{\PYGZsh{} delete the rule}
\PYG{n}{um}\PYG{o}{.}\PYG{n}{delete\PYGZus{}sub}\PYG{p}{(}\PYG{n}{context}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{Personal}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,} \PYG{n}{componentid}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{lastname}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{subname}\PYG{o}{=}\PYG{n}{subtoken}\PYG{p}{)}
\end{Verbatim}

\textbf{Import and Export of Models}

Models can be imported and exported in JSON (JavaScript Object Notation)
form using the \emph{export\_model} and \emph{import\_model} methods:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{Personis\PYGZus{}base}
\PYG{k+kn}{import} \PYG{n+nn}{Personis\PYGZus{}a}

\PYG{n}{um} \PYG{o}{=} \PYG{n}{Personis\PYGZus{}a}\PYG{o}{.}\PYG{n}{Access}\PYG{p}{(}\PYG{n}{model}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{alice}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{modeldir}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{Models}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{user}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{contactapp}\PYG{l+s}{'}\PYG{p}{,} \PYG{n}{password}\PYG{o}{=}\PYG{l+s}{'}\PYG{l+s}{secret}\PYG{l+s}{'}\PYG{p}{)}

\PYG{c}{\PYGZsh{} export a model sub tree to JSON}
\PYG{c}{\PYGZsh{} note that all evidence will also be exported.}
\PYG{n}{modeljson} \PYG{o}{=} \PYG{n}{um}\PYG{o}{.}\PYG{n}{export\PYGZus{}model}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{Personal}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,} \PYG{n}{evidence\PYGZus{}filter}\PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{all}\PYG{l+s}{"}\PYG{p}{)}
\PYG{k}{print} \PYG{n}{modeljson}

\PYG{c}{\PYGZsh{} import the same model tree but into a different context.}
\PYG{n}{um}\PYG{o}{.}\PYG{n}{import\PYGZus{}model}\PYG{p}{(}\PYG{n}{context}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{Temp}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,} \PYG{n}{partial\PYGZus{}model}\PYG{o}{=}\PYG{n}{modeljson}\PYG{p}{)}
\end{Verbatim}


\chapter{Model Definition Format}
\label{Modeldef:model-definition-format}\label{Modeldef::doc}
When creating a new model it is possible to build the tree of contexts and components from a template file
in ``Model Definition Format'' or ``modeldef''. This is useful when installing applications that need their
own subtree of contexts and components. The subtree could be built by the application using the \emph{mkcontext}
and \emph{mkcomponent} methods but there is also a ``bulk'' creation script (Src/Utils/mkmodel.py)
that reads ``modeldef'' files and creates the specified contexts, components, views, subscriptions
and initial evidence.

Modeldef files consist of a series text lines. Lines that start with \# are comments and ignored.

Lines that start with @@ specify a context to be made. The context name is in the form of a pathname starting
at the root of the model. For example:

\begin{Verbatim}[commandchars=\\\{\}]
@@Personal: description="Personal information"
\end{Verbatim}

This specifies a context called ``Personal'' in the root context of the model.

\begin{Verbatim}[commandchars=\\\{\}]
@@Personal/Health: description="Health information"
\end{Verbatim}

This specifies a context called ``Health'' in the ``Personal'' context of the model.

A short string description of the context must be included.

After a context (@@) line, that context becomes the \emph{current} context and any additional non-context elements
are created in that context until the current context is changed by another @@ line.

Components are specified using lines that begin with two minus signs (--). For example:

\begin{Verbatim}[commandchars=\\\{\}]
--firstname: type="attribute", value\_type="string", description="First name", [evidence\_type="explicit", value="Alice"]
\end{Verbatim}

this line specifies that a new component called ``firstname'' is created in the current context.
Attributes of the component are specified using name=value elements.
Initial evidence for the component is included as a sequence of bracketed sections as shown.

Subscription rules can also be included with a new component using the ``rule'' attribute. Eg:

\begin{Verbatim}[commandchars=\\\{\}]
--email: type="attribute", value\_type="string", description="email address",
\# create a subscription that will notify when email address changes
        rule="\textless{}default!./Personal/email\textgreater{} \textasciitilde{} '*' : NOTIFY 'http://www.somewhere.com/' 'email=' \textless{}./Personal/email\textgreater{}"
\end{Verbatim}

lines can be continued by breaking them after a comma.

Views are specified by lines starting with ``=='' and include a list of component pathnames. Eg:

\begin{Verbatim}[commandchars=\\\{\}]
==fullname: firstname, lastname
\end{Verbatim}


\chapter{Client/Server Protocol}
\label{Client::doc}\label{Client:client-server-protocol}
This document describes the Personis \emph{access}, \emph{ask} and \emph{tell} calls in terms of the Python method calls.

\textbf{access}:

\begin{Verbatim}[commandchars=\\\{\}]
def access(modelname=string, user=string, password=string, version="11.2")
\end{Verbatim}

The POST URL is then /access and the body is (for example):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s}{"}\PYG{l+s}{password}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{pass}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{modelname}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{bob}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{user}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{bob}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{version}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{11.2}\PYG{l+s}{"}\PYG{p}{\PYGZcb{}}
\end{Verbatim}

the return data is:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZob{}"result": "ok", "val": true\PYGZcb{}     -- on success
\PYGZob{}"result": "fail", "val": false\PYGZcb{}     -- on failure
I might change this to include a diagnostic string as the value of val.
\end{Verbatim}

\textbf{tell}:

\begin{Verbatim}[commandchars=\\\{\}]
def tell(modelname=string, user=string, password=string, version="11.2",
        context=list-of-strings, componentid=string, evidence=dict)
\end{Verbatim}

The URL is /tell

Body example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s}{"}\PYG{l+s}{modelname}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{bob}\PYG{l+s}{"}\PYG{p}{,}
\PYG{l+s}{"}\PYG{l+s}{user}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{bob}\PYG{l+s}{"}\PYG{p}{,}
\PYG{l+s}{"}\PYG{l+s}{password}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{pass}\PYG{l+s}{"}\PYG{p}{,}
\PYG{l+s}{"}\PYG{l+s}{version}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{11.2}\PYG{l+s}{"}\PYG{p}{,}
\PYG{l+s}{"}\PYG{l+s}{evidence}\PYG{l+s}{"}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s}{"}\PYG{l+s}{comment}\PYG{l+s}{"}\PYG{p}{:} \PYG{n}{null}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{evidence\PYGZus{}type}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{explicit}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{value}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{Bob}\PYG{l+s}{"}\PYG{p}{,}
                \PYG{l+s}{"}\PYG{l+s}{objectType}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{Evidence}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{source}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{demoex2}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{flags}\PYG{l+s}{"}\PYG{p}{:} \PYG{p}{[}\PYG{p}{]}\PYG{p}{,}
                \PYG{l+s}{"}\PYG{l+s}{time}\PYG{l+s}{"}\PYG{p}{:} \PYG{n}{null}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{exp\PYGZus{}time}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+s}{"}\PYG{l+s}{context}\PYG{l+s}{"}\PYG{p}{:} \PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{Personal}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,}
\PYG{l+s}{"}\PYG{l+s}{componentid}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{firstname}\PYG{l+s}{"}\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Note that the evidence dictionary should be extensible, ie not just the fields shown. Keys are strings, values can be strings/None/integer/list-of-strings

The return data is:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZob{}"result": "ok", "val": true\PYGZcb{}     -- on success
\PYGZob{}"result": "fail", "val": false\PYGZcb{}     -- on failure
I might change this to include a diagnostic string as the value of val.[a]
\end{Verbatim}

\textbf{ask}:

\begin{Verbatim}[commandchars=\\\{\}]
def ask(modelname=string, user=string, password=string, version="11.2",
        context=list-of-strings,
        resolve=dict,
        showcontexts=true-or-false,[b]
        view=list-of-(string-or-list-of-string) )
\end{Verbatim}

The resolver dictionary is extensible, keys and values are strings, \emph{view} is a list of strings or (list of strings)

The URL is /ask

Body example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s}{"}\PYG{l+s}{modelname}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{bob}\PYG{l+s}{"}\PYG{p}{,}
\PYG{l+s}{"}\PYG{l+s}{user}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{bob}\PYG{l+s}{"}\PYG{p}{,}
\PYG{l+s}{"}\PYG{l+s}{password}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{pass}\PYG{l+s}{"}\PYG{p}{,}
\PYG{l+s}{"}\PYG{l+s}{version}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{11.2}\PYG{l+s}{"}\PYG{p}{,}
\PYG{l+s}{"}\PYG{l+s}{context}\PYG{l+s}{"}\PYG{p}{:} \PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{Preferences}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{Music}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{Jazz}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{Artists}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,}
\PYG{l+s}{"}\PYG{l+s}{showcontexts}\PYG{l+s}{"}\PYG{p}{:} \PYG{n}{null}\PYG{p}{,}
\PYG{l+s}{"}\PYG{l+s}{resolver}\PYG{l+s}{"}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s}{"}\PYG{l+s}{evidence\PYGZus{}filter}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{all}\PYG{l+s}{"}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{l+s}{"}\PYG{l+s}{view}\PYG{l+s}{"}\PYG{p}{:} \PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{Miles\PYGZus{}Davis}\PYG{l+s}{"}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{Personal}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{firstname}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{]}\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The return data is a dictionary containing a result and val entries like the Access function.
The value for ``val'' is a list of dictionaries, one per component value being returned.

example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s}{"}\PYG{l+s}{result}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{ok}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{val}\PYG{l+s}{"}\PYG{p}{:}
 \PYG{p}{[}        \PYG{p}{\PYGZob{}}\PYG{l+s}{"}\PYG{l+s}{Description}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{First name}\PYG{l+s}{"}\PYG{p}{,}
        \PYG{l+s}{"}\PYG{l+s}{component\PYGZus{}type}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{attribute}\PYG{l+s}{"}\PYG{p}{,}
        \PYG{l+s}{"}\PYG{l+s}{evidencelist}\PYG{l+s}{"}\PYG{p}{:} \PYG{n}{null}\PYG{p}{,}
        \PYG{l+s}{"}\PYG{l+s}{value\PYGZus{}list}\PYG{l+s}{"}\PYG{p}{:} \PYG{n}{null}\PYG{p}{,}
        \PYG{l+s}{"}\PYG{l+s}{value}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{Bob}\PYG{l+s}{"}\PYG{p}{,}
        \PYG{l+s}{"}\PYG{l+s}{value\PYGZus{}type}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{string}\PYG{l+s}{"}\PYG{p}{,}
        \PYG{l+s}{"}\PYG{l+s}{goals}\PYG{l+s}{"}\PYG{p}{:} \PYG{p}{[}\PYG{p}{]}\PYG{p}{,}
        \PYG{l+s}{"}\PYG{l+s}{resolver}\PYG{l+s}{"}\PYG{p}{:} \PYG{n}{null}\PYG{p}{,}
        \PYG{l+s}{"}\PYG{l+s}{Identifier}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{firstname}\PYG{l+s}{"}\PYG{p}{,}
        \PYG{l+s}{"}\PYG{l+s}{objectType}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{Component}\PYG{l+s}{"}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
        \PYG{p}{\PYGZob{}}\PYG{l+s}{"}\PYG{l+s}{Description}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{Last name}\PYG{l+s}{"}\PYG{p}{,}
        \PYG{l+s}{"}\PYG{l+s}{component\PYGZus{}type}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{attribute}\PYG{l+s}{"}\PYG{p}{,}
        \PYG{l+s}{"}\PYG{l+s}{evidencelist}\PYG{l+s}{"}\PYG{p}{:} \PYG{n}{null}\PYG{p}{,}
        \PYG{l+s}{"}\PYG{l+s}{value\PYGZus{}list}\PYG{l+s}{"}\PYG{p}{:} \PYG{n}{null}\PYG{p}{,}
        \PYG{l+s}{"}\PYG{l+s}{value}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{Kummerfeld}\PYG{l+s}{"}\PYG{p}{,}
        \PYG{l+s}{"}\PYG{l+s}{value\PYGZus{}type}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{string}\PYG{l+s}{"}\PYG{p}{,}
        \PYG{l+s}{"}\PYG{l+s}{goals}\PYG{l+s}{"}\PYG{p}{:} \PYG{p}{[}\PYG{p}{]}\PYG{p}{,}
        \PYG{l+s}{"}\PYG{l+s}{resolver}\PYG{l+s}{"}\PYG{p}{:} \PYG{n}{null}\PYG{p}{,}
        \PYG{l+s}{"}\PYG{l+s}{Identifier}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{lastname}\PYG{l+s}{"}\PYG{p}{,}
        \PYG{l+s}{"}\PYG{l+s}{objectType}\PYG{l+s}{"}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{Component}\PYG{l+s}{"}\PYG{p}{\PYGZcb{}}
 \PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The POST requests should be over HTTP for now, HTTPS later. Also, a future stage of development will involve more crypto with signed, encrypted JSON.


\chapter{client Package}
\label{personis.client:client-package}\label{personis.client::doc}

\section{\texttt{client} Package}
\label{personis.client:id1}\phantomsection\label{personis.client:module-personis.client}\index{personis.client (module)}\index{Access (class in personis.client)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access}\pysiglinewithargsret{\strong{class }\code{personis.client.}\bfcode{Access}}{\emph{model='-`}, \emph{connection=None}, \emph{uri=None}, \emph{credentials=None}, \emph{http=None}, \emph{loglevel=20}, \emph{test=True}}{}
Bases: \code{object}

Client version of access for client/server system
\begin{description}
\item[{arguments:}] \leavevmode
model           model name
modelserver     model server and port
user            user name
password        password string

\end{description}

returns a user model access object
\index{ask() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access.ask}\pysiglinewithargsret{\bfcode{ask}}{\emph{context=}\optional{}, \emph{view=None}, \emph{resolver=None}, \emph{showcontexts=None}}{}~\begin{description}
\item[{arguments: (see Personis\_base for details)}] \leavevmode
context is a list giving the path of context identifiers
view is either:
\begin{quote}

an identifier of a view in the context specified
a list of component identifiers or full path lists
None indicating that the values of all components in
\begin{quote}

the context be returned
\end{quote}
\end{quote}

resolver specifies a resolver, default is the builtin resolver

\end{description}

returns a list of component objects

\end{fulllineitems}

\index{delcomponent() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access.delcomponent}\pysiglinewithargsret{\bfcode{delcomponent}}{\emph{context=}\optional{}, \emph{componentid=None}}{}
Delete an existing component in a given context
arguments:
\begin{quote}

context - a list giving the path to the required context
id - the id for a componen
\end{quote}
\begin{description}
\item[{returns:}] \leavevmode
None on success
a string error message on error

\end{description}

\end{fulllineitems}

\index{delcontext() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access.delcontext}\pysiglinewithargsret{\bfcode{delcontext}}{\emph{context=}\optional{}}{}
Delete an existing context
arguments:
\begin{quote}

context - a list giving the path to the required context
\end{quote}
\begin{description}
\item[{returns:}] \leavevmode
None on success
a string error message on error

\end{description}

\end{fulllineitems}

\index{delete\_sub() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access.delete_sub}\pysiglinewithargsret{\bfcode{delete\_sub}}{\emph{context=}\optional{}, \emph{componentid=None}, \emph{subname=None}}{}
arguments:
context is a list giving the path of context identifiers
componentid designates the component subscribed to
subname is the subscription name

\end{fulllineitems}

\index{deleteapp() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access.deleteapp}\pysiglinewithargsret{\bfcode{deleteapp}}{\emph{app=None}}{}
deletes an app

\end{fulllineitems}

\index{delview() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access.delview}\pysiglinewithargsret{\bfcode{delview}}{\emph{context=}\optional{}, \emph{viewid=None}}{}
Delete an existing view in a given context
arguments:
\begin{quote}

context - a list giving the path to the required context
viewid - the id for the view
\end{quote}
\begin{description}
\item[{returns:}] \leavevmode
None on success

\end{description}

\end{fulllineitems}

\index{export\_model() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access.export_model}\pysiglinewithargsret{\bfcode{export\_model}}{\emph{context=}\optional{}, \emph{resolver=None}}{}
arguments:
context is the context to export
resolver is a string containing the name of a resolver
\begin{quote}

or
\end{quote}
\begin{description}
\item[{resolver is a dictionary containing information about resolver(s) to be used and arguments}] \leavevmode
the ``resolver'' key gives the name of a resolver to use, if not present the default resolver is used
the ``evidence\_filter'' key specifies an evidence filter
eg `evidence\_filter' =  ``all'' returns all evidence,
\begin{quote}

``last10'' returns last 10 evidence items,
``last1'' returns most recent evidence item,
None returns no evidence
\end{quote}

\end{description}

\end{fulllineitems}

\index{getcontext() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access.getcontext}\pysiglinewithargsret{\bfcode{getcontext}}{\emph{context=}\optional{}, \emph{getsize=False}}{}
Get context information
arguments:
\begin{quote}

context - a list giving the path to the required context
getsize - True if the size in bytes of the context subtree is required
\end{quote}

\end{fulllineitems}

\index{getpermission() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access.getpermission}\pysiglinewithargsret{\bfcode{getpermission}}{\emph{context=None}, \emph{componentid=None}, \emph{app=None}}{}
gets permissions for a context (if componentid is None) or
a component
returns a tuple (ask,tell)

\end{fulllineitems}

\index{getresolvers() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access.getresolvers}\pysiglinewithargsret{\bfcode{getresolvers}}{}{}
Return a list of the available resolver names

\end{fulllineitems}

\index{import\_model() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access.import_model}\pysiglinewithargsret{\bfcode{import\_model}}{\emph{context=}\optional{}, \emph{partial\_model=None}}{}
arguments:
context is the context to import into
partial\_model is a json encoded string containing the partial model

\end{fulllineitems}

\index{list\_subs() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access.list_subs}\pysiglinewithargsret{\bfcode{list\_subs}}{\emph{context=}\optional{}, \emph{componentid=None}}{}
arguments:
context is a list giving the path of context identifiers
componentid designates the component with subscriptions attached

\end{fulllineitems}

\index{listapps() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access.listapps}\pysiglinewithargsret{\bfcode{listapps}}{}{}
returns array of registered app names

\end{fulllineitems}

\index{mkcomponent() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access.mkcomponent}\pysiglinewithargsret{\bfcode{mkcomponent}}{\emph{context=}\optional{}, \emph{componentobj=None}}{}
Make a new component in a given context
arguments:
\begin{quote}

context - a list giving the path to the required context
componentobj - a Component object
\end{quote}
\begin{description}
\item[{returns:}] \leavevmode
None on success
a string error message on error

\end{description}

\end{fulllineitems}

\index{mkcontext() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access.mkcontext}\pysiglinewithargsret{\bfcode{mkcontext}}{\emph{context=}\optional{}, \emph{contextobj=None}}{}
Make a new context in a given context
arguments:
\begin{quote}

context - a list giving the path to the required context
contextobj - a Context object
\end{quote}

\end{fulllineitems}

\index{mkview() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access.mkview}\pysiglinewithargsret{\bfcode{mkview}}{\emph{context=}\optional{}, \emph{viewobj=None}}{}
Make a new view in a given context
arguments:
\begin{quote}

context - a list giving the path to the required context
viewobj - a View object
\end{quote}
\begin{description}
\item[{returns:}] \leavevmode
None on success
a string error message on error

\end{description}

\end{fulllineitems}

\index{registerapp() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access.registerapp}\pysiglinewithargsret{\bfcode{registerapp}}{\emph{app=None}, \emph{desc='`}, \emph{password=None}}{}
registers a password for an app
app name is a string (needs checking TODO)
app passwords are stored at the top level .model db

\end{fulllineitems}

\index{set\_goals() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access.set_goals}\pysiglinewithargsret{\bfcode{set\_goals}}{\emph{context=}\optional{}, \emph{componentid=None}, \emph{goals=None}}{}
arguments:
context is a list giving the path of context identifiers
componentid designates the component with subscriptions attached
goals is a list of paths to components that are:
\begin{quote}

goals for this componentid if it is not of type goal
components that contribute to this componentid if it is of type goal
\end{quote}

\end{fulllineitems}

\index{setpermission() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access.setpermission}\pysiglinewithargsret{\bfcode{setpermission}}{\emph{context=None}, \emph{componentid=None}, \emph{app=None}, \emph{permissions=\{\}}}{}
sets ask/tell permission for a context (if componentid is None) or
a component

\end{fulllineitems}

\index{setresolver() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access.setresolver}\pysiglinewithargsret{\bfcode{setresolver}}{\emph{context}, \emph{componentid}, \emph{resolver}}{}
set the resolver for a given component in a given context
arguments:
\begin{quote}

context - a list giving the path to the required context
componentid - the id for a given component
resolver - the id of the resolver
\end{quote}
\begin{description}
\item[{returns:}] \leavevmode
None on success
a string error message on error

\end{description}

\end{fulllineitems}

\index{subscribe() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access.subscribe}\pysiglinewithargsret{\bfcode{subscribe}}{\emph{context=}\optional{}, \emph{view=None}, \emph{subscription=None}}{}
arguments:
context is a list giving the path of context identifiers
view is either:
\begin{quote}

an identifier of a view in the context specified
a list of component identifiers or full path lists
None indicating that the values of all components in
\begin{quote}

the context be returned
\end{quote}

subscription is a Subscription object
\end{quote}

\end{fulllineitems}

\index{tell() (personis.client.Access method)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Access.tell}\pysiglinewithargsret{\bfcode{tell}}{\emph{context=}\optional{}, \emph{componentid=None}, \emph{evidence=None}}{}
arguments:
context - a list giving the path to the required context
componentid - identifier of the component
evidence - evidence object to add to the component

\end{fulllineitems}


\end{fulllineitems}

\index{Component (class in personis.client)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Component}\pysiglinewithargsret{\strong{class }\code{personis.client.}\bfcode{Component}}{\emph{**kargs}}{}
component object
Identifier  the identifier of the component
\begin{quote}

unique in the context
\end{quote}

Description readable description
creation\_time   time of creation of the component
component\_type  {[}''attribute'', ``activity'', ``knowledge'', ``belief'', ``preference'', ``goal''{]}
value\_type  {[}''string'', ``number'',''boolean'', ``enum'', ``JSON''{]}
value\_list    a list of strings that are the possible values for type ``enum''
value       the resolved value
resolver    default resolver for this component
goals       list of component paths eg {[} {[}'Personal', `Health', `weight'{]}, ...{]}
evidencelist    list of evidence objects

\end{fulllineitems}

\index{Context (class in personis.client)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Context}\pysiglinewithargsret{\strong{class }\code{personis.client.}\bfcode{Context}}{\emph{**kargs}}{}
context object
Identifier  the identifier of the component
\begin{quote}

unique in the context
\end{quote}

Description readable description
resolver    default resolver for components in this context

\end{fulllineitems}

\index{Evidence (class in personis.client)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Evidence}\pysiglinewithargsret{\strong{class }\code{personis.client.}\bfcode{Evidence}}{\emph{**kargs}}{}
evidence object
evidence\_type   ``explicit'', \# given by the user
\begin{quote}

``implicit'', \# observed by the machine
``exmachina'', \# told (to the user) by the machine
``inferred'', \# evidence generated by a subscription inference 
``stereotype''{]} \# evidence added by a stereotype
\end{quote}

source  string indicating source of evidence
value   any python object
comment string with extra information about the evidence
flags   a list of strings eg ``goal''
time    notional creation time optionally given by user
creation\_time actual time evidence item was created
useby   timestamp evidence expires (if required)
\index{EvidenceTypes (personis.client.Evidence attribute)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.Evidence.EvidenceTypes}\pysigline{\bfcode{EvidenceTypes}\strong{ = {[}'explicit', `implicit', `exmachina', `inferred', `stereotype'{]}}}
explicit: given by the user  (given)
implicit: observed by the machine (observation)
exmachina: told (to the user) by the machine (told)
inferred: evidence generated by inference (external or internal)
stereotype: evidence added by a stereotype

\end{fulllineitems}


\end{fulllineitems}

\index{View (class in personis.client)}

\begin{fulllineitems}
\phantomsection\label{personis.client:personis.client.View}\pysiglinewithargsret{\strong{class }\code{personis.client.}\bfcode{View}}{\emph{**kargs}}{}
view object
Identifier  the identifier of the component
\begin{quote}

unique in the context
\end{quote}

Description readable description

\end{fulllineitems}



\section{\texttt{util} Module}
\label{personis.client:util-module}\label{personis.client:module-personis.client.util}\index{personis.client.util (module)}

\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{p}
\item {\texttt{personis.client}}, \pageref{personis.client:module-personis.client}
\item {\texttt{personis.client.util}}, \pageref{personis.client:module-personis.client.util}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
